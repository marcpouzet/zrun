(* recursive functions *)
let rec f1<<n>> =
  match size n with
  | 0 -> 1
  | _ -> f1<<n-1>> + 1

let main1 () = assert (f1<<42>> = 43)

let f3 =
  let rec or_<<n>> = fun (x) returns (o)
    match size n with
    | 0 -> o = false
    | 1 -> o = x.(0)
    | _ -> 
      do o = or_<<n/2>>(x.(0 .. n/2-1)) || or_<<n/2>>(x.(n/2 .. n-1)) done in
  or_

let main2 () = assert (f3 <<4>> [|true; false; false; false |] = true)

let f33 =
  let rec sum_<<n>> = fun (x) returns (o)
    match size n with
    | 0 -> o = 0
    | 1 -> o = x.(0)
    | _ -> o = (sum_<<n/2>>(x.(0 .. n/2-1))) +
                  (sum_<<n/2>>(x.(n/2 .. n-1))) in
  sum_

let main3 () = assert ((f33 <<4>>) [|1; 2; 3; 4 |] = 10)

let main4 () = let f<<n>>() = n + 1 in f<<4>>

let rec or_n<<n>> = fun (x) returns (o)
  match size n with
  | 0 -> o = false
  | 1 -> o = x.(0)
  | _ -> o = or_n<<n/2>>(x.(0 .. n/2-1)) || or_n<<n/2>>(x.(n/2 .. n-1))

let main5() returns ()
  assert (or_n<<4>>([|true; false; false; false |]))

let rec or_n2<<n>>(x) returns (o)
  local m
  do
  match size n with
  | 0 -> m = false
  | 1 -> m = x.(0)
  | n -> m = (or_n2<<n/2>>(x.(0 .. n/2-1))) || (or_n2<<n/2>>(x.(n/2 .. n-1)))
  and o = m
  done


let main5() returns ()
  assert
    (or_n2<<8>>([|true; false; false; false; true; false; false; false |]))

let main45() returns (o)
  let m = foreach(15) returns ([|xi|]) do xi = false done in
  do o = m done

let main45() returns (o)
  let m = foreach(15) returns ([|xi|]) do xi = false done in
  do o = m done

let main55() returns (o)
  let m = foreach(15) returns ([|xi|]) do xi = false done in
  do o = or_n<<15>>(m) done
  
let main555() returns (o)
  let m = foreach(15) returns ([|xi|]) do xi = false done in
  let static v = or_n<<15>> in
  do o = v(m) done

  
let rec fby_n1<<n>> = node (x) returns (o)
  local m
  do o = x fby m
  and match size n with
      | 0 -> do m = x done
      | n -> do m = run (fby_n1<<n-1>>)(x) done
  done

let node main6() =
  let rec x = 0 -> pre x + 1 in
  run (fby_n1<<6>>)(x)

let rec node fby_n2<<n>>(x) returns (o)
  local m
  do o = x fby m
  and match size n with
      | 0 -> m = x
      | _ -> m = run (fby_n2<<n-1>>)(x)
  done

let node main7() =
  let rec x = 0 -> pre x + 1 in
  run (fby_n2<<6>>)(x)

let node main8() returns ()
  let rec x = 0 -> pre x + 1 in
  assert (run(fby_n1<<3>>)(x) = run(fby_n2<<3>>)(x))

let xor x y = if x then not y else y

let adder(x, y, c) returns (s, c')
 do s = xor (xor x y) c
 and c' = if x then y || c else y && c
 done

let main9() =
  let x = [| true; false; true;  false; true;  false; true;  false |] in
  let y = [| true; true;  false; false; true;  true;  false; false |] in
  let c = [| true; true;  true;  true;  false; false; false; false |] in
  forward (xi in x, yi in y, ci in c) returns ([|zi|], [|c'i|])
    do zi, c'i = adder(xi, yi, ci) done

let rec add_n11<<n>>(x) returns (o)
  o = match size n with
  | 0 -> 0
  | 1 -> if x.(0) then 1 else 0
  | k -> add_n11<<n-1>>(x.(1 .. n-1)) + 1

(* let m() =
  let t = [|0;1;2;3;4;5|] in
  t.(0 .. -1), t.(5 .. 4) *)

let main10() returns (r1)
  r1 = add_n11<<4>>([|true; false; false; false |])

(*
let rec add_n<<n>> = fun (x, y, c) returns (o, c')
  match size n with
  | 0 -> do o = [||] and c' = false done
  | _ ->
       let s, c = adder(x.(0), y.(0), c) in
       match size n with
       | 0 -> do o = [|s|] and c' = c done
       | n -> let o', c = add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), c) in
              do o = [|s|] ++ o' and c' = c done

let main10() returns ()
  assert (add_n<<4>>([|true; false; false; false |], 
                     [|true; false; false; false |], false) =
          ([| false; true; false; false |], false))
*)
